class VirtualMachine:
    """
    Virtual Machine to execute quadruples generated by the LittleDuck compiler.

    Attributes:
        quadruples (list): List of quadruples to execute.
        virtual_memory (VirtualMemory): Instance managing virtual memory segments.
        function_table (FunctionTable): Instance containing function definitions.
        program_counter (int): Current quadruple index being executed.
        call_stack (list): Stack to manage function calls and return addresses.
        running (bool): Flag to control the execution loop.
        print_traversal (bool): Flag to enable detailed execution tracing.
    """

    def __init__(self, quadruples, virtual_memory, function_table, print_traversal=False):
        """
        Initializes the VirtualMachine with quadruples, virtual memory, and function table.

        Args:
            quadruples (list): List of quadruples to execute.
            virtual_memory (VirtualMemory): Instance managing virtual memory segments.
            function_table (FunctionTable): Instance containing function definitions.
            print_traversal (bool, optional): Enable detailed execution tracing. Defaults to False.
        """
        self.quadruples = quadruples
        self.virtual_memory = virtual_memory
        self.function_table = function_table
        self.program_counter = 0
        self.call_stack = []  # To keep track of return addresses and function contexts
        self.running = True
        self.print_traversal = print_traversal

    def run(self):
        """
        Executes the list of quadruples until the program terminates.
        """
        while self.running and self.program_counter < len(self.quadruples):
            quad = self.quadruples[self.program_counter]
            operation = quad[0]
            if self.print_traversal:
                print(f"Executing Quadruple {self.program_counter}: {quad}")
            self.handle_operation(operation, quad)
            self.program_counter += 1

    def handle_operation(self, operation, quad):
        """
        Dispatches the quadruple operation to the appropriate handler.

        Args:
            operation (str): The operation code of the quadruple.
            quad (tuple): The quadruple to execute.
        """
        handlers = {
            "GOTO": self.handle_goto,
            "GOTOF": self.handle_gotof,
            "ERA": self.handle_era,
            "PARAM": self.handle_param,
            "GOSUB": self.handle_gosub,
            "FUNC_START": self.handle_func_start,
            "ENDFUNC": self.handle_endfunc,
            "print": self.handle_print,
            "print_str": self.handle_print_str,
            "print_newline": self.handle_print_newline,
            "=": self.handle_assignment,
            "+": self.handle_arithmetic,
            "-": self.handle_arithmetic,
            "*": self.handle_arithmetic,
            "/": self.handle_arithmetic,
            "<": self.handle_arithmetic,
            ">": self.handle_arithmetic,
            "==": self.handle_arithmetic,
            "!=": self.handle_arithmetic,
            "END": self.handle_end,
        }
        handler = handlers.get(operation, self.handle_unknown)
        handler(quad)

    def handle_unknown(self, quad):
        """
        Handles unknown operations by raising an exception.

        Args:
            quad (tuple): The quadruple with an unknown operation.

        Raises:
            Exception: Indicates an unknown operation.
        """
        raise Exception(f"Unknown operation '{quad[0]}' encountered.")

    def handle_goto(self, quad):
        """
        Handles the GOTO operation by setting the program counter to the target quadruple.

        Args:
            quad (tuple): The GOTO quadruple.
        """
        target = quad[3]
        if self.print_traversal:
            print(f"GOTO: Jumping to quadruple index {target}")
        self.program_counter = target - 1  # -1 because it will be incremented after execution

    def handle_gotof(self, quad):
        """
        Handles the GOTOF operation by conditionally jumping to a target quadruple if the condition is false.

        Args:
            quad (tuple): The GOTOF quadruple.
        """
        condition_address = quad[1]
        target = quad[3]
        condition_value = self.virtual_memory.get_value(condition_address)
        if self.print_traversal:
            print(f"GOTOF: Condition at address {condition_address} is {condition_value}")
        if not condition_value:
            if self.print_traversal:
                print(f"GOTOF condition false, jumping to quadruple index {target}")
            self.program_counter = target - 1  # -1 because it will be incremented after execution

    def handle_era(self, quad):
        """
        Handles the ERA operation by preparing for a function call.
        Allocates a new local memory frame.

        Args:
            quad (tuple): The ERA quadruple.
        """
        func_name = quad[1]
        if self.print_traversal:
            print(f"ERA: Preparing to call function '{func_name}'")
        # Push a new local memory frame
        self.virtual_memory.push_local_memory()
        # Retrieve function information
        if func_name not in self.function_table.functions:
            raise Exception(f"Error: Function '{func_name}' not declared.")
        func_info = self.function_table.get_function(func_name)
        # Push function call info (only func_start) onto the call stack
        self.call_stack.append({'func_start': func_info['quad_start']})

    def handle_param(self, quad):
        """
        Handles the PARAM operation by assigning an argument to a function's parameter.

        Args:
            quad (tuple): The PARAM quadruple.
        """
        arg_address = quad[1]
        param_address = quad[3]
        arg_value = self.virtual_memory.get_value(arg_address)
        # Assign the argument value to the parameter address in the current local memory frame
        self.virtual_memory.set_value(param_address, arg_value)
        if self.print_traversal:
            print(f"PARAM: Set parameter at address {param_address} to value {arg_value}")

    def handle_gosub(self, quad):
        """
        Handles the GOSUB operation by jumping to the function's starting quadruple.
        Saves the return address to the call stack.

        Args:
            quad (tuple): The GOSUB quadruple.
        """
        func_name = quad[1]
        func_start = quad[3]
        if self.print_traversal:
            print(f"GOSUB: Jumping to function '{func_name}' starting at quadruple {func_start}")
        # Retrieve function call info from the call stack
        if not self.call_stack:
            raise Exception("Error: GOSUB without a corresponding ERA.")
        call_info = self.call_stack.pop()
        if 'func_start' not in call_info:
            raise Exception("Error: Invalid call_info structure.")
        func_start_from_call_info = call_info['func_start']
        # Determine the return address (quadruple after GOSUB)
        return_address = self.program_counter + 1
        # Push the return address onto the call stack
        self.call_stack.append({'return_address': return_address})
        # Jump to the function's starting quadruple
        self.program_counter = func_start_from_call_info - 1  # -1 because it will be incremented after execution

    def handle_func_start(self, quad):
        """
        Handles the FUNC_START operation. Typically, no action is needed as the program counter is already at the start.

        Args:
            quad (tuple): The FUNC_START quadruple.
        """
        func_name = quad[1]
        if self.print_traversal:
            print(f"FUNC_START: Starting execution of function '{func_name}'")

    def handle_endfunc(self, quad):
        """
        Handles the ENDFUNC operation by returning control to the caller.
        Pops the current local memory frame and sets the program counter to the return address.

        Args:
            quad (tuple): The ENDFUNC quadruple.
        """
        if self.print_traversal:
            print("ENDFUNC: Ending function execution")
        # Pop the current local memory frame
        self.virtual_memory.pop_local_memory()
        # Retrieve the return address from the call stack
        if not self.call_stack:
            raise Exception("Error: ENDFUNC without a corresponding GOSUB.")
        call_info = self.call_stack.pop()
        return_address = call_info.get('return_address')
        if return_address is None:
            raise Exception("Error: No return address found for ENDFUNC.")
        if self.print_traversal:
            print(f"ENDFUNC: Returning to quadruple index {return_address}")
        # Set the program counter to the return address
        self.program_counter = return_address - 1  # -1 because it will be incremented after execution

    def handle_print(self, quad):
        """
        Handles the print operation by outputting the value of an expression.

        Args:
            quad (tuple): The print quadruple.
        """
        expr_address = quad[1]
        value = self.virtual_memory.get_value(expr_address)
        print(value, end='')
        if self.print_traversal:
            print(f"PRINT: Printed value {value}")

    def handle_print_str(self, quad):
        """
        Handles the print_str operation by outputting a string literal.

        Args:
            quad (tuple): The print_str quadruple.
        """
        string_address = quad[1]
        string_value = self.virtual_memory.get_value(string_address)
        print(string_value, end='')
        if self.print_traversal:
            print(f"PRINT_STR: Printed string '{string_value}'")

    def handle_print_newline(self, quad):
        """
        Handles the print_newline operation by outputting a newline character.

        Args:
            quad (tuple): The print_newline quadruple.
        """
        print()
        if self.print_traversal:
            print("PRINT_NEWLINE: Printed newline")

    def handle_assignment(self, quad):
        """
        Handles the assignment operation by setting a variable's value.

        Args:
            quad (tuple): The assignment quadruple.
        """
        value_address = quad[1]
        target_address = quad[3]
        value = self.virtual_memory.get_value(value_address)
        self.virtual_memory.set_value(target_address, value)
        if self.print_traversal:
            print(f"ASSIGNMENT: Assigned value {value} from address {value_address} to address {target_address}")

    def handle_arithmetic(self, quad):
        """
        Handles arithmetic and comparison operations by computing the result and storing it.

        Args:
            quad (tuple): The arithmetic quadruple.
        """
        operation = quad[0]
        left_address = quad[1]
        right_address = quad[2]
        result_address = quad[3]
        left_value = self.virtual_memory.get_value(left_address)
        right_value = self.virtual_memory.get_value(right_address)

        # Perform the arithmetic or comparison operation
        if operation == "+":
            result = left_value + right_value
            op_symbol = '+'
        elif operation == "-":
            result = left_value - right_value
            op_symbol = '-'
        elif operation == "*":
            result = left_value * right_value
            op_symbol = '*'
        elif operation == "/":
            result = left_value / right_value
            op_symbol = '/'
        elif operation == "<":
            result = left_value < right_value
            op_symbol = '<'
        elif operation == ">":
            result = left_value > right_value
            op_symbol = '>'
        elif operation == "==":
            result = left_value == right_value
            op_symbol = '=='
        elif operation == "!=":
            result = left_value != right_value
            op_symbol = '!='
        else:
            raise Exception(f"Unknown arithmetic operation '{operation}'.")

        # Store the result in the designated address
        self.virtual_memory.set_value(result_address, result)
        if self.print_traversal:
            print(f"ARITHMETIC: Computed {left_value} {op_symbol} {right_value} = {result} at address {result_address}")

    def handle_end(self, quad):
        """
        Handles the END operation by terminating the program execution.

        Args:
            quad (tuple): The END quadruple.
        """
        if self.print_traversal:
            print("END: Terminating program execution")
        self.running = False
